<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手写浅拷贝</title>
</head>

<body>
    <script>
        // 1、es6的浅拷贝 :assign
        const obj1 = { a: 1, b: 2 };
        const obj2 = { c: 3, d: 4 };
        const shallowCopy1 = Object.assign({}, obj1, obj2);
        console.log('es6浅拷贝:', shallowCopy1); // { a: 1, b: 2, c: 3, d: 4 }
        // 缺点：如果简明相同会被覆盖，第一个参数不能为null或者是undefied
        // 2、扩展运算符
        const shallowCopy2 = { ...obj1, ...obj2 };
        console.log('扩展运算符浅拷贝:', shallowCopy2); // { a: 3, b: 4 }
        // 3、数组中的方法：slice
        const arr = [1, 2, 3, 4];
        const shallowCopy3 = arr.slice();
        console.log('数组slice浅拷贝:', shallowCopy3); // [1, 2, 3, 4]
        // 4、concat:合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。
        const arr2 = [5, 6, 7];
        const shallowCopy4 = arr.concat(arr2);
        console.log('数组concat浅拷贝:', shallowCopy4); // [1, 2, 3, 4, 5, 6, 7]
        // 实现一下浅拷贝叭
        function shallowCopy(obj) {
            // 判断obj是否为对象，只拷贝对象
            if (!obj || typeof obj !== 'object') {
                return obj;
            }
            // 判断obj的类型
            const newObj = Array.isArray(obj) ? [] : {};
            // 进行遍历，是obj的属性我们才进行拷贝
            // 仅对对象和数组及逆行拷贝
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    newObj[key] = obj[key];
                }
            }
            // 返回 newObj;
            return newObj;
        }

        // 测试
        const obj3 = { a: 1, b: { c: 2 } };
        const copiedObj = shallowCopy(obj3);
        console.log('手写浅拷贝:', copiedObj); // { a: 1, b: { c: 2 } }
        const obj4 = { a: 1, b: { c: 2 } };
        const copy = shallowCopy(obj4); // 浅拷贝
        copy.b.c = 3;
        console.log(copy.b.c); // 输出 3（原对象也被修改）

    </script>

</body>

</html>